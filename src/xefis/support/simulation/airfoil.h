/* vim:ts=4
 *
 * Copyleft 2008…2018  Michał Gawron
 * Marduk Unix Labs, http://mulabs.org/
 *
 * This program is free software: you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation, either version 3 of the License, or
 * (at your option) any later version.
 *
 * Visit http://www.gnu.org/licenses/gpl-3.0.html for more information on licensing.
 */

#ifndef XEFIS__SUPPORT__SIMULATION__AIRFOIL_H__INCLUDED
#define XEFIS__SUPPORT__SIMULATION__AIRFOIL_H__INCLUDED

// Standard:
#include <cstddef>

// Xefis:
#include <xefis/config/all.h>
#include <xefis/support/earth/air.h>
#include <xefis/support/math/space.h>
#include <xefis/support/simulation/body_part.h>
#include <xefis/support/simulation/airfoil_shape.h>
#include <xefis/support/simulation/atmosphere.h>
#include <xefis/support/simulation/body.h>


namespace xf::sim {

struct AirfoilControl
{
	/*
	 * Input
	 */

	// Deflection angle about the pivot axis of the AirfoilShape:
	si::Angle		deflection_angle	{ 0_deg };

	/*
	 * Output
	 */

	AngleOfAttack	angle_of_attack		{ 0_deg, 0_deg };
};


/**
 * Lift-generating airframe part.
 */
class Airfoil: public BodyPart
{
  public:
	// Ctor
	explicit
	Airfoil (AirfoilShape const&,
			 SpaceVector<si::Length, BodyFrame> const& position,
			 // TODO SpaceMatrix<double, BodyFrame, AirfoilSplineFrame> const& mount_rotation,
			 si::Mass,
			 SpaceMatrix<si::MomentOfInertia, PartFrame> const& moment_of_inertia);

	// Dtor
	virtual
	~Airfoil() = default;

	/**
	 * Control object.
	 */
	[[nodiscard]]
	AirfoilControl&
	control() noexcept
		{ return _control; }

	/**
	 * Control object.
	 */
	[[nodiscard]]
	AirfoilControl const&
	control() const noexcept
		{ return _control; }

	/**
	 * AirfoilShape object.
	 */
	[[nodiscard]]
	AirfoilShape const&
	shape() const noexcept
		{ return _shape; }

	/**
	 * Set new AirfoilShape object.
	 */
	void
	set_shape (AirfoilShape const& shape)
		{ _shape = shape; }

	/**
	 * Return rotation matrix from airfoil frame to body frame.
	 */
	[[nodiscard]]
	SpaceMatrix<double, BodyFrame, AirfoilSplineFrame> const&
	mount_rotation() const noexcept
		{ return _airfoil_shape_to_body_transform; }

	/**
	 * Set new rotation matrix from airfoil frame to body frame.
	 */
	void
	set_mount_rotation (SpaceMatrix<double, BodyFrame, AirfoilSplineFrame> const& matrix)
	{
		_airfoil_shape_to_body_transform = matrix;
		_body_to_airfoil_shape_transform = inv (matrix);
	}

	/**
	 * Return airfoil-shape-to-body transformation matrix.
	 */
	[[nodiscard]]
	SpaceMatrix<double, BodyFrame, AirfoilSplineFrame> const&
	airfoil_shape_to_body_transform() const noexcept
		{ return _airfoil_shape_to_body_transform; }

	/**
	 * Return body-to-airfoil-shape- transformation matrix.
	 */
	[[nodiscard]]
	SpaceMatrix<double, AirfoilSplineFrame, BodyFrame> const&
	body_to_airfoil_shape_transform() const noexcept
		{ return _body_to_airfoil_shape_transform; }

	/**
	 * Calculate resultant force-torque generated by the airfoil.
	 *
	 * \param	deflection_angle
	 *			Rotation angle of the airfoil about the pivot axis, that is Z axis of AirfoilShape.
	 * \param	relative_wind
	 *			Wind force expressed in body frame of reference.
	 */
	[[nodiscard]]
	ForceTorque<BodyFrame>
	forces (Atmosphere::State<BodyFrame> const&) override;

  private:
	AirfoilControl										_control;
	AirfoilShape										_shape;
	// Rotation from airfoil-shape frame of reference to body frame of reference, when angle about pivot is 0.
	SpaceMatrix<double, BodyFrame, AirfoilSplineFrame>	_airfoil_shape_to_body_transform	{ math::unit };
	SpaceMatrix<double, AirfoilSplineFrame, BodyFrame>	_body_to_airfoil_shape_transform	{ math::unit };
};

} // namespace xf::sim

#endif

