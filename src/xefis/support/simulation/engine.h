/* vim:ts=4
 *
 * Copyleft 2008…2018  Michał Gawron
 * Marduk Unix Labs, http://mulabs.org/
 *
 * This program is free software: you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation, either version 3 of the License, or
 * (at your option) any later version.
 *
 * Visit http://www.gnu.org/licenses/gpl-3.0.html for more information on licensing.
 */

#ifndef XEFIS__SUPPORT__SIMULATION__ENGINE_H__INCLUDED
#define XEFIS__SUPPORT__SIMULATION__ENGINE_H__INCLUDED

// Standard:
#include <cstddef>

// Xefis:
#include <xefis/config/all.h>
#include <xefis/support/math/space.h>
#include <xefis/support/nature/physics.h>
#include <xefis/support/simulation/n_body/body_part.h>
#include <xefis/support/simulation/atmosphere.h>


namespace xf::sim {

// X points to the thrust vector, Y to the right, Z down:
using EngineFrame = PartFrame;


struct EngineControl
{
	/*
	 * Input
	 */

	si::Power	power	{ 0_W };

	/*
	 * Output
	 */

	si::Force				thrust				{ 0_N };
	si::AngularVelocity		angular_velocity	{ 0_radps };
	si::Temperature			temperature			{ 0_K };
};


/**
 * TODO polymorphic: ElectricMotor (using Propeller or DuctFan), CombustionEngine (using Propeller or Ductfan)(efficiency changes with air)
 * TODO Electric motor efficiency doesn't change with air, but the motor can fail (highly reduced efficiency) if temperature is > 70° for some period of time
 * (loss of magnetic field in neodymium magnets).
 * TODO simulate ElectricMotor temperature according to wind, generated wind by propeller, air temperature and thermal resistance
 * TODO simulate rotational speed and return this data in EngineControl
 * TODO Although motor efficiency doesn't change with air, propeller efficiency DOES!!!
 * Airfoil's frame of reference: X point to the direction of thrust, Y to the usual right side, Z points down.
 */
class Engine: public BodyPart<AirframeFrame, EngineFrame>
{
  public:
	// Ctor
	using BodyPart::BodyPart;

	/**
	 * Control object.
	 */
	[[nodiscard]]
	EngineControl&
	control() noexcept
		{ return _control; }

	/**
	 * Control object.
	 */
	[[nodiscard]]
	EngineControl const&
	control() const noexcept
		{ return _control; }

	/**
	 * Calculate resultant force-torque generated by the engine.
	 */
	[[nodiscard]]
	ForceTorque<AirframeFrame>
	forces (AtmosphereState<AirframeFrame> const&) override;

  private:
	EngineControl _control;
};


/**
 * Return typical rotation matrix for rotating engine's frame vectors to airframe's frame vectors.
 */
[[nodiscard]]
constexpr RotationMatrix<AirframeFrame, PartFrame>
engine_to_airframe_rotation()
{
	return { math::unit };
}

} // namespace xf::sim

#endif

