/* vim:ts=4
 *
 * Copyleft 2008…2018  Michał Gawron
 * Marduk Unix Labs, http://mulabs.org/
 *
 * This program is free software: you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation, either version 3 of the License, or
 * (at your option) any later version.
 *
 * Visit http://www.gnu.org/licenses/gpl-3.0.html for more information on licensing.
 */

#ifndef XEFIS__SUPPORT__SIMULATION__ENGINE_H__INCLUDED
#define XEFIS__SUPPORT__SIMULATION__ENGINE_H__INCLUDED

// Standard:
#include <cstddef>

// Xefis:
#include <xefis/config/all.h>
#include <xefis/support/math/space.h>
#include <xefis/support/nature/physics.h>
#include <xefis/support/simulation/body_part.h>
#include <xefis/support/simulation/atmosphere.h>


namespace xf::sim {

struct EngineControl
{
	/*
	 * Input
	 */

	si::Power	power	{ 0_W };

	/*
	 * Output
	 */

	si::Force				thrust				{ 0_N };
	si::AngularVelocity		angular_velocity	{ 0_radps };
	si::Temperature			temperature			{ 0_K };
};


/**
 * Positions are expressed in airframe's frame of reference.
 * TODO polymorphic: ElectricMotor (using Propeller or DuctFan), CombustionEngine (using Propeller or Ductfan)(efficiency changes with air)
 * TODO Electric motor efficiency doesn't change with air, but the motor can fail (highly reduced efficiency) if temperature is > 70° for some period of time
 * (loss of magnetic field in neodymium magnets).
 * TODO simulate ElectricMotor temperature according to wind, generated wind by propeller, air temperature and thermal resistance
 * TODO simulate rotational speed and return this data in EngineControl
 * TODO Although motor efficiency doesn't change with air, propeller efficiency DOES!!!
 */
class Engine: public BodyPart
{
  public:
	// Ctor
	using BodyPart::BodyPart;

	/**
	 * Control object.
	 */
	[[nodiscard]]
	EngineControl&
	control() noexcept
		{ return _control; }

	/**
	 * Control object.
	 */
	[[nodiscard]]
	EngineControl const&
	control() const noexcept
		{ return _control; }

	/**
	 * Return rotation matrix from engine frame to body frame.
	 */
	[[nodiscard]]
	SpaceMatrix<double, BodyFrame, EngineFrame> const&
	mount_rotation() const noexcept
		{ return _engine_to_body; }

	/**
	 * Set new rotation matrix from airfoil frame to body frame.
	 */
	void
	set_mount_rotation (SpaceMatrix<double, BodyFrame, EngineFrame> const& matrix)
	{
		_engine_to_body = matrix;
		_body_to_engine = inv (matrix);
	}

	/**
	 * Calculate resultant force-torque generated by the engine.
	 */
	[[nodiscard]]
	ForceTorque<BodyFrame>
	forces (Atmosphere::State<BodyFrame> const&) override;

  private:
	EngineControl								_control;
	// Rotation from engine frame of reference to body frame of reference:
	SpaceMatrix<double, BodyFrame, EngineFrame>	_engine_to_body	{ math::unit };
	SpaceMatrix<double, EngineFrame, BodyFrame>	_body_to_engine	{ math::unit };
};

} // namespace xf::sim

#endif

